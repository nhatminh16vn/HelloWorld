<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<title>Game Hardcore x999999</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #1e3c72, #2a5298);
    color: white;
  }
  #gameArea {
    width: 100vw;
    height: 100vh;
    position: relative;
    overflow: hidden;
  }
  #player {
    width: 50px;
    height: 50px;
    background: linear-gradient(135deg, #ff416c, #ff4b2b);
    border-radius: 12px;
    position: absolute;
    box-shadow: 0 0 15px #ff416c;
    transition: box-shadow 0.2s ease;
  }
  #player.hit {
    animation: flashRed 0.3s;
  }
  @keyframes flashRed {
    0%,100% { box-shadow: 0 0 15px #ff416c; background: linear-gradient(135deg, #ff416c, #ff4b2b); }
    50% { box-shadow: 0 0 25px #ff0000; background: #ff0000; }
  }
  .obstacle {
    width: 100px;
    height: 100px;
    background: linear-gradient(45deg, #434343, #000000);
    position: absolute;
    border-radius: 10px;
    box-shadow: inset 0 0 15px #000000;
  }
  #goal {
    width: 60px;
    height: 60px;
    background: radial-gradient(circle, #00ff6a, #00802b);
    position: absolute;
    border-radius: 15px;
    box-shadow: 0 0 15px #00ff6a;
    filter: drop-shadow(0 0 8px #00ff6a);
  }
  #message, #levelDisplay, #timer, #highScoreDisplay {
    position: absolute;
    font-size: 24px;
    padding: 6px 12px;
    background: rgba(0,0,0,0.6);
    border-radius: 12px;
    user-select: none;
  }
  #message {
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 40px;
    color: #ff4b2b;
    display: none;
    text-shadow: 0 0 10px #ff4b2b;
  }
  #levelDisplay {
    top: 10px;
    right: 10px;
  }
  #timer {
    top: 10px;
    left: 10px;
  }
  #highScoreDisplay {
    top: 50px;
    right: 10px;
  }
  /* Boss style */
  .boss {
    width: 150px;
    height: 150px;
    background: radial-gradient(circle, #800000, #400000);
    position: absolute;
    border-radius: 20px;
    border: 5px solid #ff0000;
    box-shadow: 0 0 20px #ff0000;
    animation: bossMove 2s infinite alternate ease-in-out;
  }
  @keyframes bossMove {
    from { transform: translateX(0); }
    to { transform: translateX(350px); }
  }
  /* Bullet style */
  .bullet {
    width: 15px;
    height: 15px;
    background: radial-gradient(circle, #ffff00, #ff9900);
    border-radius: 50%;
    position: absolute;
    box-shadow: 0 0 12px #ffff00;
  }
</style>
</head>
<body>
  <div id="gameArea">
    <div id="player"></div>
    <div id="goal"></div>
    <div id="message"></div>
    <div id="levelDisplay">Level: 1</div>
    <div id="timer">‚è±Ô∏è 30s</div>
    <div id="highScoreDisplay">üèÖ K·ª∑ l·ª•c: 1</div>
  </div>

  <script>
    const gameArea = document.getElementById("gameArea");
    const player = document.getElementById("player");
    const goal = document.getElementById("goal");
    const message = document.getElementById("message");
    const levelDisplay = document.getElementById("levelDisplay");
    const timerDisplay = document.getElementById("timer");
    const highScoreDisplay = document.getElementById("highScoreDisplay");

    const playerSize = 50;
    let posX = 0, posY = 0;
    let obstacles = [];
    let bullets = [];
    let level = 1;
    const maxLevels = 30;
    let step = 10;
    let timeLeft = 30;
    let timer;
    let gameOver = false;
    let highScore = localStorage.getItem("highScore") || 1;
    highScoreDisplay.innerText = `üèÖ K·ª∑ l·ª•c: ${highScore}`;

    function getRandom(min, max) {
      return Math.floor(Math.random() * (max - min)) + min;
    }

    function createObstacle(x, y) {
      const obs = document.createElement("div");
      obs.classList.add("obstacle");
      obs.style.left = `${x}px`;
      obs.style.top = `${y}px`;
      gameArea.appendChild(obs);
      obstacles.push(obs);
    }

    function clearObstacles() {
      obstacles.forEach(o => o.remove());
      obstacles = [];
    }

    function clearBullets() {
      bullets.forEach(b => b.remove());
      bullets = [];
    }

    function checkCollision(rect1, rect2) {
      return !(
        rect1.right < rect2.left ||
        rect1.left > rect2.right ||
        rect1.bottom < rect2.top ||
        rect1.top > rect2.bottom
      );
    }

    function isOverlapping(x, y, width, height, existingElements) {
      const rect1 = {
        left: x,
        right: x + width,
        top: y,
        bottom: y + height
      };
      for (const el of existingElements) {
        const rect2 = el.getBoundingClientRect();
        if (!(rect1.right < rect2.left || rect1.left > rect2.right ||
              rect1.bottom < rect2.top || rect1.top > rect2.bottom)) {
          return true;
        }
      }
      return false;
    }

    function spawnPlayer() {
      let tries = 0;
      do {
        posX = getRandom(0, window.innerWidth - playerSize);
        posY = getRandom(0, window.innerHeight - playerSize);
        tries++;
      } while (isOverlapping(posX, posY, playerSize, playerSize, obstacles) && tries < 50);
      player.style.left = posX + "px";
      player.style.top = posY + "px";
    }

    function spawnGoal() {
      let tries = 0;
      let goalX, goalY;
      do {
        goalX = getRandom(0, window.innerWidth - 60);
        goalY = getRandom(0, window.innerHeight - 60);
        tries++;
      } while (isOverlapping(goalX, goalY, 60, 60, obstacles) && tries < 50);
      goal.style.left = goalX + "px";
      goal.style.top = goalY + "px";
    }

    let boss = null;
    let bossDirection = 1;
    let bossSpeed = 2;

    // T·∫°o ƒë·∫°n b·∫Øn t·ª´ boss
    function createBullet(x, y, dx, dy) {
      const bullet = document.createElement("div");
      bullet.classList.add("bullet");
      bullet.style.left = x + "px";
      bullet.style.top = y + "px";
      gameArea.appendChild(bullet);
      bullets.push({el: bullet, dx, dy});
    }

    function moveBullets() {
      bullets.forEach((b, i) => {
        let left = parseFloat(b.el.style.left);
        let top = parseFloat(b.el.style.top);
        left += b.dx;
        top += b.dy;
        b.el.style.left = left + "px";
        b.el.style.top = top + "px";

        // N·∫øu ra ngo√†i m√†n th√¨ x√≥a
        if (left < 0 || left > window.innerWidth || top < 0 || top > window.innerHeight) {
          b.el.remove();
          bullets.splice(i, 1);
        }

        // Va ch·∫°m v·ªõi player
        const playerRect = player.getBoundingClientRect();
        const bulletRect = b.el.getBoundingClientRect();
        if (checkCollision(playerRect, bulletRect)) {
          endGame("üí• B·∫°n b·ªã tr√∫ng ƒë·∫°n! Thua r·ªìi.");
          player.classList.add("hit");
          setTimeout(() => player.classList.remove("hit"), 300);
        }
      });
    }

    function startLevel() {
      clearObstacles();
      clearBullets();
      if (boss) {
        boss.remove();
        boss = null;
      }
      gameOver = false;
      step = 10 + level * 0.8; // TƒÉng t·ªëc d·∫ßn
      timeLeft = 30 - Math.floor(level / 10) * 5; // C·ª© 10 level gi·∫£m 5 gi√¢y
      if (timeLeft < 10) timeLeft = 10;

      // T·∫°o ch∆∞·ªõng ng·∫°i v·∫≠t
      if ([10, 20, 30].includes(level)) {
        // Boss level
        boss = document.createElement("div");
        boss.classList.add("boss");
        boss.style.top = getRandom(100, window.innerHeight - 200) + "px";
        boss.style.left = getRandom(100, window.innerWidth - 400) + "px";
        gameArea.appendChild(boss);
        obstacles.push(boss);
      } else {
        // T·∫°o ch∆∞·ªõng ng·∫°i v·∫≠t nhi·ªÅu v√† kh√≥ h∆°n
        const obstacleCount = Math.min(5 + level * 1.5, 40);
        for (let i = 0; i < obstacleCount; i++) {
          let ox, oy, tries = 0;
          do {
            ox = getRandom(0, window.innerWidth - 100);
            oy = getRandom(0, window.innerHeight - 100);
            tries++;
          } while (isOverlapping(ox, oy, 100, 100, obstacles) && tries < 50);
          createObstacle(ox, oy);
        }
      }

      spawnPlayer();
      spawnGoal();

      levelDisplay.innerText = `Level: ${level}`;
      message.style.display = "none";
      timerDisplay.innerText = `‚è±Ô∏è ${timeLeft}s`;

      clearInterval(timer);
      timer = setInterval(() => {
        if (gameOver) return;
        timeLeft--;
        if (timeLeft <= 0) {
          endGame("‚è∞ H·∫øt gi·ªù! Thua r·ªìi.");
        } else {
          timerDisplay.innerText = `‚è±Ô∏è ${timeLeft}s`;
        }
      }, 1000);
    }

    function endGame(text) {
      if (gameOver) return;
      message.innerText = text;
      message.style.display = "block";
      gameOver = true;
      clearInterval(timer);

      // C·∫≠p nh·∫≠t high score
      if (level > highScore) {
        highScore = level;
        localStorage.setItem("highScore", highScore);
        highScoreDisplay.innerText = `üèÖ K·ª∑ l·ª•c: ${highScore}`;
        message.innerText += " üéâ K·ª∑ l·ª•c m·ªõi!";
      }
    }

    function nextLevel() {
      level++;
      if (level > maxLevels) {
        endGame("üèÜ B·∫°n ƒë√£ ho√†n th√†nh 30 m√†n ch∆°i! Tuy·ªát v·ªùi!");
        return;
      }
      startLevel();
    }

    document.addEventListener("keydown", (event) => {
      if (gameOver) return;

      let newX = posX;
      let newY = posY;

      switch(event.key) {
        case "ArrowUp": newY -= step; break;
        case "ArrowDown": newY += step; break;
        case "ArrowLeft": newX -= step; break;
        case "ArrowRight": newX += step; break;
      }

      // Gi·ªõi h·∫°n ra ngo√†i m√†n h√¨nh
      newX = Math.max(0, Math.min(newX, window.innerWidth - playerSize));
      newY = Math.max(0, Math.min(newY, window.innerHeight - playerSize));

      player.style.left = newX + "px";
      player.style.top = newY + "px";

      const playerRect = player.getBoundingClientRect();

      // Ki·ªÉm tra va ch·∫°m v·ªõi ch∆∞·ªõng ng·∫°i v·∫≠t
      for (let obs of obstacles) {
        const obsRect = obs.getBoundingClientRect();
        if (checkCollision(playerRect, obsRect)) {
          endGame("üí• B·∫°n ƒë√£ va ch·∫°m! Thua r·ªìi.");
          player.classList.add("hit");
          setTimeout(() => player.classList.remove("hit"), 300);
          return;
        }
      }

      // Ki·ªÉm tra v·ªÅ ƒë√≠ch
      const goalRect = goal.getBoundingClientRect();
      if (checkCollision(playerRect, goalRect)) {
        nextLevel();
      }

      posX = newX;
      posY = newY;
    });

    // ƒêi·ªÅu khi·ªÉn boss di chuy·ªÉn v√† b·∫Øn ƒë·∫°n
    function bossActions() {
      if (!boss) return;

      let left = parseFloat(boss.style.left);
      left += bossSpeed * bossDirection;

      // ƒê·ªïi chi·ªÅu khi ch·∫°m c·∫°nh
      if (left < 0 || left > window.innerWidth - 150) {
        bossDirection *= -1;
      } else {
        boss.style.left = left + "px";
      }

      // B·∫Øn ƒë·∫°n ng·∫´u nhi√™n v·ªõi x√°c su·∫•t tƒÉng d·∫ßn theo level
      if (Math.random() < 0.03 + level * 0.002) {
        // B·∫Øn ƒë·∫°n t·ª´ boss ƒë·∫øn player
        const bossRect = boss.getBoundingClientRect();
        const playerRect = player.getBoundingClientRect();
        const startX = bossRect.left + bossRect.width / 2;
        const startY = bossRect.top + bossRect.height / 2;
        const dirX = playerRect.left + playerRect.width / 2 - startX;
        const dirY = playerRect.top + playerRect.height / 2 - startY;
        const length = Math.sqrt(dirX * dirX + dirY * dirY);
        const bulletSpeed = 6 + level * 0.2;
        const dx = (dirX / length) * bulletSpeed;
        const dy = (dirY / length) * bulletSpeed;
        createBullet(startX, startY, dx, dy);
      }
    }

    // V√≤ng l·∫∑p game ch√≠nh
    function gameLoop() {
      if (!gameOver) {
        bossActions();
        moveBullets();
      }
      requestAnimationFrame(gameLoop);
    }

    // B·∫Øt ƒë·∫ßu game l·∫ßn ƒë·∫ßu
    startLevel();
    gameLoop();
  </script>
</body>
</html>
