<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Maze Auto Play</title>
  <style>
    body { background: #111; display: flex; justify-content: center; align-items: center; height: 100vh; }
    canvas { border: 2px solid #eee; background: #222; }
  </style>
</head>
<body>
<canvas id="maze" width="600" height="600"></canvas>
<script>
const canvas = document.getElementById('maze');
const ctx = canvas.getContext('2d');
const cols = 20, rows = 20;
const cellSize = canvas.width / cols;

class Cell {
  constructor(x, y) {
    this.x = x; this.y = y;
    this.walls = [true, true, true, true];
    this.visited = false;
  }

  draw() {
    const x = this.x * cellSize;
    const y = this.y * cellSize;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;

    if (this.walls[0]) drawLine(x, y, x + cellSize, y);
    if (this.walls[1]) drawLine(x + cellSize, y, x + cellSize, y + cellSize);
    if (this.walls[2]) drawLine(x + cellSize, y + cellSize, x, y + cellSize);
    if (this.walls[3]) drawLine(x, y + cellSize, x, y);

    if (this.visited) {
      ctx.fillStyle = "#333";
      ctx.fillRect(x, y, cellSize, cellSize);
    }
  }
}

function drawLine(x1, y1, x2, y2) {
  ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
}

const grid = [], stack = [];
for (let y = 0; y < rows; y++) for (let x = 0; x < cols; x++) grid.push(new Cell(x, y));
function index(x, y) {
  if (x < 0 || y < 0 || x >= cols || y >= rows) return -1;
  return x + y * cols;
}

function removeWalls(a, b) {
  const dx = a.x - b.x, dy = a.y - b.y;
  if (dx === 1) { a.walls[3] = b.walls[1] = false; }
  else if (dx === -1) { a.walls[1] = b.walls[3] = false; }
  if (dy === 1) { a.walls[0] = b.walls[2] = false; }
  else if (dy === -1) { a.walls[2] = b.walls[0] = false; }
}

let current = grid[0];
function generateStep() {
  current.visited = true;
  const neighbors = getUnvisitedNeighbors(current);
  if (neighbors.length > 0) {
    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
    stack.push(current);
    removeWalls(current, next);
    current = next;
  } else if (stack.length > 0) current = stack.pop();
  draw();
  if (stack.length > 0) requestAnimationFrame(generateStep);
}

function getUnvisitedNeighbors(cell) {
  const {x, y} = cell;
  const neighbors = [];
  const top = grid[index(x, y - 1)];
  const right = grid[index(x + 1, y)];
  const bottom = grid[index(x, y + 1)];
  const left = grid[index(x - 1, y)];
  if (top && !top.visited) neighbors.push(top);
  if (right && !right.visited) neighbors.push(right);
  if (bottom && !bottom.visited) neighbors.push(bottom);
  if (left && !left.visited) neighbors.push(left);
  return neighbors;
}

let player = { x: 0, y: 0 };
const goal = { x: cols - 1, y: rows - 1 };

function drawPlayer() {
  ctx.fillStyle = 'lime';
  ctx.fillRect(player.x * cellSize + 5, player.y * cellSize + 5, cellSize - 10, cellSize - 10);
  ctx.fillStyle = 'red';
  ctx.fillRect(goal.x * cellSize + 8, goal.y * cellSize + 8, cellSize - 16, cellSize - 16);
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  grid.forEach(c => c.draw());
  drawPlayer();
}

function movePlayerAuto(path) {
  if (!path || path.length === 0) return;
  const next = path.shift();
  player.x = next.x;
  player.y = next.y;
  draw();
  if (player.x === goal.x && player.y === goal.y) {
    setTimeout(() => alert("ðŸŽ‰ AI Ä‘Ã£ tháº¯ng!"), 100);
  } else {
    setTimeout(() => movePlayerAuto(path), 100);
  }
}

// BFS Ä‘á»ƒ tÃ¬m Ä‘Æ°á»ng
function findPathBFS(start, end) {
  const queue = [start];
  const visited = new Set();
  const cameFrom = {};
  const key = (x, y) => `${x},${y}`;
  visited.add(key(start.x, start.y));

  while (queue.length > 0) {
    const current = queue.shift();
    if (current.x === end.x && current.y === end.y) {
      // XÃ¢y dá»±ng láº¡i Ä‘Æ°á»ng Ä‘i
      const path = [];
      let c = key(end.x, end.y);
      while (c !== key(start.x, start.y)) {
        const [cx, cy] = c.split(',').map(Number);
        path.unshift({x: cx, y: cy});
        c = cameFrom[c];
      }
      return path;
    }

    const i = index(current.x, current.y);
    const cell = grid[i];
    const dirs = [
      {dx: 0, dy: -1, wall: 0},
      {dx: 1, dy: 0, wall: 1},
      {dx: 0, dy: 1, wall: 2},
      {dx: -1, dy: 0, wall: 3}
    ];

    for (let d of dirs) {
      if (!cell.walls[d.wall]) {
        const nx = current.x + d.dx, ny = current.y + d.dy;
        const nk = key(nx, ny);
        if (!visited.has(nk)) {
          visited.add(nk);
          cameFrom[nk] = key(current.x, current.y);
          queue.push({x: nx, y: ny});
        }
      }
    }
  }
  return null;
}

// KÃ­ch hoáº¡t tá»± chÆ¡i báº±ng phÃ­m A
window.addEventListener('keydown', (e) => {
  if (e.key === 'a' || e.key === 'A') {
    const path = findPathBFS(player, goal);
    if (path) movePlayerAuto(path);
  }
});

generateStep(); // báº¯t Ä‘áº§u sinh mÃª cung
</script>
</body>
</html>
