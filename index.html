<!DOCTYPE html>
<html>
<head>
    <title>Hardest Game: 3D Voxel Racer</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; }
    </style>
</head>
<body>
    <div id="info">Arrow keys to drive. Try not to crash!</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        // ====== SETUP ======
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ====== GAME STATE ======
        const player = {
            x: 100, y: 300, angle: 0, speed: 0,
            turnSpeed: 0.03, maxSpeed: 5
        };
        const track = generateTrack();
        const enemies = [{ x: 150, y: 250, angle: 0, speed: 2 }];
        let score = 0;

        // Generate a winding procedural track
        function generateTrack() {
            const track = [];
            for (let i = 0; i < 1000; i++) {
                track.push({
                    x: Math.sin(i * 0.1) * 200 + canvas.width / 2,
                    y: i * 10
                });
            }
            return track;
        }

        // ====== 3D RENDERING (RAYCASTING) ======
        function render3D() {
            // Sky
            ctx.fillStyle = "#87CEEB";
            ctx.fillRect(0, 0, canvas.width, canvas.height / 2);

            // Ground
            ctx.fillStyle = "#2E8B57";
            ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);

            // Walls (raycasting)
            for (let x = 0; x < canvas.width; x++) {
                const rayAngle = player.angle - 0.5 + x / canvas.width;
                let distance = 0;
                let hitWall = false;

                while (!hitWall && distance < 1000) {
                    distance += 2;
                    const rayX = player.x + Math.cos(rayAngle) * distance;
                    const rayY = player.y + Math.sin(rayAngle) * distance;

                    // Track collision check
                    const trackSegment = track[Math.floor(rayY / 10) % track.length];
                    if (Math.abs(rayX - trackSegment.x) < 30) {
                        hitWall = true;
                        const wallHeight = (canvas.height * 50) / distance;
                        ctx.fillStyle = `hsl(${200 - distance / 2}, 100%, 50%)`;
                        ctx.fillRect(
                            x,
                            canvas.height / 2 - wallHeight / 2,
                            2,
                            wallHeight
                        );
                    }
                }
            }
        }

        // ====== 2D MINIMAP (DEBUG) ======
        function renderMinimap() {
            const scale = 0.2;
            ctx.save();
            ctx.translate(20, canvas.height - 150);
            ctx.scale(scale, scale);

            // Draw track
            ctx.strokeStyle = "white";
            ctx.beginPath();
            track.forEach((segment, i) => {
                if (i === 0) ctx.moveTo(segment.x, segment.y);
                else ctx.lineTo(segment.x, segment.y);
            });
            ctx.stroke();

            // Draw player
            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.arc(player.x, player.y, 5, 0, Math.PI * 2);
            ctx.fill();

            // Draw enemies
            ctx.fillStyle = "blue";
            enemies.forEach(enemy => {
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore();
        }

        // ====== PHYSICS & UPDATES ======
        function update() {
            // Player controls
            if (keys.ArrowUp) player.speed = Math.min(player.speed + 0.05, player.maxSpeed);
            if (keys.ArrowDown) player.speed = Math.max(player.speed - 0.05, -player.maxSpeed / 2);
            if (keys.ArrowLeft) player.angle -= player.turnSpeed * player.speed;
            if (keys.ArrowRight) player.angle += player.turnSpeed * player.speed;

            // Friction
            player.speed *= 0.95;
            if (Math.abs(player.speed) < 0.01) player.speed = 0;

            // Move player
            player.x += Math.cos(player.angle) * player.speed;
            player.y += Math.sin(player.angle) * player.speed;

            // AI opponents
            enemies.forEach(enemy => {
                const targetSegment = track[Math.floor(enemy.y / 10) % track.length];
                enemy.angle = Math.atan2(targetSegment.x - enemy.x, targetSegment.y - enemy.y);
                enemy.x += Math.cos(enemy.angle) * enemy.speed;
                enemy.y += Math.sin(enemy.angle) * enemy.speed;
            });

            // Score (distance traveled)
            score = Math.floor(player.y / 10);
        }

        // ====== INPUT HANDLING ======
        const keys = {};
        window.addEventListener("keydown", e => keys[e.code] = true);
        window.addEventListener("keyup", e => keys[e.code] = false);

        // ====== GAME LOOP ======
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            render3D();
            renderMinimap();
            update();

            // Display score
            ctx.fillStyle = "white";
            ctx.font = "20px Arial";
            ctx.fillText(`Score: ${score}`, 20, 40);

            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
